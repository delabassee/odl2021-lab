# Lab 7: Records

## Overview

In this 12-minute lab, you will use **Records**, a new Java language feature that went through 2 preview rounds (JDK 14, JDK 15) before being made final and permanent in Java 16.

Records provide a compact syntax for declaring classes which are transparent holders for shallowly immutable data. A record can be best thought of as a nominal tuple that enables us to easily and quickly model immutable "plain data" aggregates.

## A simple Record


Similar to enums, records are technically a special form of classes optimized for a specific situation, i.e. modeling data aggregates in the case of records.

**1. Declaring a record**

Create a `Person.java` class 

```
<copy>
cd ~ && nano Person.java
</copy>
```
with the following content.
```
<copy>
public record Person(String lastname, String firstname) {}
</copy>
```

You just declared, using the new `record` keyword, a **record class** whose name is "Person". This record has 2 variables, or more precisely 2 **components**: `lastname` and `firstname`.
It is those components that makes up the **record state**. So to declare a record, you primarily have to declare its components.
The record state will enable this record to acquire several standard members automatically.


**2. Record's acquired standard members**


To see which standard members this record will get, you first have to compile it.

```
<copy>
javac Person.java
</copy>
```

You can now use [`javap`](https://docs.oracle.com/en/java/javase/15/docs/specs/man/javap.html) to decompile this record class, and see the different standard members that were acquired automatically.


üí° the `-p` parameter instructs `javap` to display the private members of the class being decompilled.

```
> <copy>javap -p Person</copy>
Compiled from "Person.java"
public final class Person extends java.lang.Record {
  private final java.lang.String lastname;
  private final java.lang.String firstname;
  public Person(java.lang.String, java.lang.String);
  public final java.lang.String toString();
  public final int hashCode();
  public final boolean equals(java.lang.Object);
  public java.lang.String lastname();
  public java.lang.String firstname();
}
```
We can observe that this record has automatically acquired:

* 2 private final fields (`lastname` and `firstname`) that match the record's components, the record state declaration.
* a canonical constructor taking 2 parameters that correspond, again, the Record's components (`lastname` and `firstname`).
* 2 public accessor methods aptly named `lastname()` and `firstname()` to access the record's components.
* 3 'common' methods: `toString()`, `hashCode()` and `equals()`.

In addtion, we can see that the Person record extends the [`java.lang.Record`](https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/Record.html) abstract class.

All of that is generated by the Java compiler. Using Records, we can declare transparent data carrier classes using a clean and concise syntax. It is also possible to override those methods implementation or supply a custom constructor (ex. to perform data validation or normalization).


**3. Using a record**

To use the record simply create a simple `TestRecord.java` class.


```
<copy>
nano TestRecord.java
</copy>
```

```
<copy>
class TestRecord {

   public static void main(String ...args) {
      var attendee = new Person("Doe", "Jane");
      System.out.println(attendee);
   }
}
</copy>
```

Compile and run the test class.

```
> javac TestRecord.java

> java TestRecord
Person[lastname=Doe, firstname=Jane]
```

üí° Thanks to [Launch Single-File Source-Code Programs (JEP 330)](https://openjdk.java.net/jeps/330) introduced in JDK 11, the above 2 commands (`javac TestRecord.java & java TestRecord`) can be combined and simplifed with `java TestRecord.java`

As mentioned earlier, the generated implementations can be overridden. For example, to override the `toString` method, change it as follow...

```
<copy>
public record Person(String lastname, String firstname) {  
   @Override 
   public String toString() {
      return "Person{firstname="+firstname+", lastname="+lastname+"}";
   }
}
</copy>
```

Compile and run the test class.

```
> javac TestRecord.java & java TestRecord
Person{firstname=Jane, lastname=Doe}
```

It is also possible to customize the constructor, for the example to check the components aren't null.

```
<copy>
import java.util.*;

public record Person(String lastname, String firstname) {	
	
	public Person (String lastname, String firstname) {	
		Objects.requireNonNull(lastname);
		Objects.requireNonNull(firstname);
		this.lastname = lastname;
		this.firstname = firstname;
   }
}
</copy>		
```


Although this constructor is easy to understand, its syntax is still quite verbose! Thanks to the **Compact Constructor** syntax of records, we can omit the constructor arguments and the different assignments. After all, those components are known and are mandatory, so why not rely on the Java compiler again to simply our life?

üí° Do notice that a record compact constructor doesn't take any parameters as they are already known and fixed, i.e. it's simply the record components, the record state. 

```
<copy>
import java.util.*;

public record Person(String lastname, String firstname) {    

    public Person { 
        Objects.requireNonNull(lastname);
        Objects.requireNonNull(firstname);
   }
}
</copy>		
```

Finally, records can also implement interfaces, ex. `java.lang.Comparable`, `java.io.Serializable`, etc. And regarding that topic, serialization, it should be mentioned that records are serialized differently than ordinary serializable objects. In fact, records use a specific, well defined, serialization protocol that is particularly safe as 
* the serialization relies only on the record state components
* the de-serialization uses only the canonical constructor

This is another benefit of records, serialization/deserialization is safe! That safety complements nicely with the data-oriented nature of records.


## A Speaker Record

Back to the Conference application (`cd ~/odl-java-hol`), it exposes simple REST endpoints to get speaker-related information.

* http://{public-ip-address}:8080/speakers ‚û° Get all speakers 

* http://{public-ip-address}:8080/speakers/company/oracle ‚û° Get speakers for a given company

* http://{public-ip-address}:8080/speakers/lastname/delabassee ‚û° Get speaker by its lastname

* http://{public-ip-address}:8080/speakers/track/java ‚û° Get speakers for a given track

* http://{public-ip-address}:8080/speakers/029 ‚û° Get speaker details for a given id


Browse the source code to understand how things work.


* `Main.java` defines the routings, including the `"/speakers"` path and its related `speakerService` handler.

* `SpeakerService.java` defines the various handlers under the `"/speakers"` path, ex. `"/speakers/lastname"`, `"/speakers/company"`, etc.

The `Speaker.java` class is interesting as it models the Speaker type with all its details (last name, first name, etc.), i.e. it is a data aggregate that represents a speaker. Once created a speaker is effectively immutable as the class is `final`. Moreover there is no way to change the fields (ex. all fields are `private` and there are no setters).

Migrating this regular class to a record is straightforward. Just replace the `Speaker.java` class content with the following Speaker record declaration. This declaration includes the different components related to a speaker. 

```
<copy>
nano src/main/java/conference/Speaker.java
</copy>
```

```
<copy>
package conference;
public record Speaker (String id,
                       String firstName,
                       String lastName,
                       String title,
                       String company,
                       Track track) {}
</copy>
```

üí° The Java compiler will automatically generate a default constructor. If needed, this constructor can be customized. Moreover, the compiler will also generate default implementations of the `toString`, the `equals`, and the `hashCode` methods. If required, those default implementations can be overridden. Finally, the Java compiler will also generate accessor methods for each component of the Record.


If you now compile the application (`mvn package`), you will get multiple errors. Can you guess why?

```
‚Ä¶src/main/java/conference/SpeakerRepository.java:[52,69] cannot find symbol
   symbol:   method getLastName()
   location: variable e of type conference.Speaker
‚Ä¶src/main/java/conference/SpeakerRepository.java:[62,77] cannot find symbol
   symbol:   method getTrack()
   location: variable e of type conference.Speaker
‚Ä¶
```

Those errors make sense as the `Speaker.java` class is using the old [JavaBeans](https://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html) getter convention to provide access to its private fields. Records on the other hand rely on (automatically generated) accessor methods to enable access to its various (immutable) components. So that needs to be fixed in the conference application code! Go through the `SpeakerRepository.java` class and make sure to use accessor methods for accessing components instead of getters. This needs to be fixed for all components of the Speaker record (lastName, company, etc.).


```
<copy>
nano src/main/java/conference/SpeakerRepository.java
</copy>
```

For example, change 
```
public List<Speaker> getAll() {
   List<Speaker> allSpeakers = speakers.stream()
       .sorted(Comparator.comparing(Speaker::getLastName)) // getter
       .collect(Collectors.toList());
   return allSpeakers;
}
```
to
```
<copy>
public List<Speaker> getAll() {
   List<Speaker> allSpeakers = speakers.stream()
      .sorted(Comparator.comparing(Speaker::lastName)) // accessor method
      .collect(Collectors.toList());
   return allSpeakers;
}
</copy>
```


Compile the application and test it (ex. http://{public-ip-address}:8080/speakers). You will notice that the application now works but it doesn't return any data!?

The `Speaker.java` class is relying on the JSON-B (JSON Binding) API support to automatically marshall Java objects to their equivalent JSON representations. The issue you are facing is that **records** is a fairly recent feature. Not all JSON-B providers support that feature yet. For example Eclipse Yasson, Helidon's default JSON-B provider, doesn't support records yet. And that explains why the returned results are empty. The good news is that things are evolving rapidly, ex. Apache Johnson, and Jackson are already supporting records, and more will follow.


To fix this problem, we simply need to use a JSON-B provider that supports Records, ex. Jackson v2.12 or greater. 

Add the following Jackson dependency in the `pom.xml`

```
<copy>
<dependency>
    <groupId>io.helidon.media</groupId>
    <artifactId>helidon-media-jackson</artifactId>
</dependency>
</copy>
```

üí° This lab uses the latest version of Helidon (2.2.1) which in turn uses Jackson v2.12, so you're good to go! If you happen to use an older Helidon version, you can manually bump the Jackson version by updating the application `pom.xml` as follows.


```
<copy>	
<dependencyManagement>
   <dependencies>
      <dependency>
         <groupId>com.fasterxml.jackson</groupId>
         <artifactId>jackson-bom</artifactId>
         <version>2.12.1</version>
         <type>pom</type>
         <scope>import</scope>
      </dependency>
      <dependency>
         <groupId>com.fasterxml.jackson.core</groupId>
         <artifactId>jackson-annotations</artifactId>
         <version>2.12.1</version>
      </dependency>
   </dependencies>
</dependencyManagement>
</copy>
```

The last thing you need to do is instruct the application to use Jackson.

```
<copy>
nano src/main/java/conference/Main.java
</copy>
```

Simply replace
``` 
.addMediaSupport(JsonbSupport.create())
```
with
```
<copy>.addMediaSupport(JacksonSupport.create())</copy>
```
and update the imports

```
<copy>
import io.helidon.media.jackson.JacksonSupport;
</copy>
```

Compile the application and test it again (ex. http://{public-ip-address}:8080/speakers), it now works!

You can notice that using Records leads to a more concise, more readable code when it comes to model data aggregates! Moreover, as more frameworks add support for Records, (ex. Jackson), this will lead to simpler and cleaner Java code.

## A Speaker Record with JSONP (optional)


In the previous exercise, we have used Jackson for its ability to automatically marshall Java objects, including Records instances, to equivalent JSON representations. Another approach would be to use the JSONP API to manually construct a JSON representation from a Record. 

This can be done by adding the following `toJson` method to the `Speaker.java` record.

```
<copy>
nano src/main/java/conference/Speaker.java
</copy>
```

```
<copy>
JsonObject toJson() {
   JsonObject payload = Json.createObjectBuilder()
      .add("id", id)
      .add("firstName", firstName)
      .add("lastName", lastName)
      .add("title", title)
      .add("company", company)
      .add("track", track.toString())
      .build();
   return payload;
}
</copy>
```

üí° Make sure to update the Record class' `import`'s accordingly.

```
<copy>
import javax.json.Json;
import javax.json.JsonObject;
</copy>
```

and update the code to return a List of `JsonObject` instead of List of `Speaker`.	

For example, update the `getAll` method in the the `SpeakerService.java` class

```
<copy>
nano src/main/java/conference/SpeakerService.java
</copy>
```
 

```
List<Speaker> allSpeakers = this.speakers.getAll();
if (allSpeakers.size() > 0)
   response.send(allSpeakers);
else Util.sendError(response, 400, "getAll - no speaker found!?");
```
to use the Streams API and the newly added `toJson` method to return a `List` of `JsonObject` as follow. 
```
<copy>
List<Speaker> allSpeakers = this.speakers.getAll();
if (allSpeakers.size() > 0) {
      response.send(allSpeakers.stream()
                .map(Speaker::toJson)
                .collect(Collectors.toList()));
} else Util.sendError(response, 400, "getAll - no speaker found!?");
</copy>
```


üìù Make sure to do this for all `SpeakerService.java` methods (`getByCompany`, `getByTrack`, `getSpeakersById`) as you just did for the `getAll` method.


This approach, while more cumbersome, shows that custom methods can be added to Records.


## Local Records (optional)


When you are developing applications, think how many times you are creating intermediate values that are a simple group of variables? That should be very frequent! The Record feature is perfect to cope with such a use-case.

Local Record is a feature introduced in the second Record preview in JDK 15. Local Records offer a convenient option to declare a record inside a method, close to where it is used.

For this exercise, let's pretend that you want to return a simpler form of Speaker, ex. just the last name/first name pair and the company.

1. Update the `getAll` method

```
<copy>
nano src/main/java/conference/SpeakerService.java
</copy>
```
to include a Local Record, i.e. within the body of the `getAll` method!
```
<copy>
record SpeakerSummary(String last, String first, String company) {}
</copy>
```

2. Adapt the the `getAll` method to create, using the Streams API, a list of `SpeakerSummary` instead of a list of `Speaker`. 


```
<copy>
List<Speaker> allSpeakers = this.speakers.getAll();
if (allSpeakers.size() > 0) {
   response.send(allSpeakers.stream()
      .map(s -> new SpeakerSummary(s.lastName(), s.firstName(), s.company()))
      .collect(Collectors.toList()));
} else Util.sendError(response, 400, "getAll - no speaker found!?");
</copy>
```

If you now test the endpoint, you will get the shorter speaker representation (see the right column below).

üí° Use `curl` or FireFox to test this, not the Web UI as it needs to updated to cope with the updated JSON payload.

![](./images/lab7-1.png " ")


üìù Make sure to update all `SpeakerService.java` methods for the new `SpeakerSummary` record. As an additional exercise, try to create different Records.

üí° FYI. This change will impact the main Web page of the application. It won't be able to display all the speaker's details.


## Stream.toList()

Each new Java release comes with a set of new Java language features (ex. Records in JDK 16), with JDK enhancements (ex. the `jpackage` tool in JDK 16). But this is just the tip of the iceberg! In addition to bug and security fixes, there are many smaller improvements done across the platform, from the HotSpot JVM to the Core libraries. And Java 16 is no exception to this rule!

One example is the new [java.util.stream.toList()](https://download.java.net/java/early_access/jdk16/docs/api/java.base/java/util/stream/Stream.html#toList()) method introduced in Java 16 which returns an immutable List containing the elements of a stream.

```
<copy>nano src/main/java/conference/SpeakerRepository.java</copy>
```

For example, we could replace the terminal operation 

```
List<Speaker> allSpeakers = speakers.stream()
     .sorted(Comparator.comparing(Speaker::lastName))
     .collect(Collectors.toList());
```

with this new method

```
<copy>
List<Speaker> allSpeakers = speakers.stream()
     .sorted(Comparator.comparing(Speaker::lastName))
     .toList();
</copy>
```

üí° Make sure to read the [javadoc](https://download.java.net/java/early_access/jdk16/docs/api/java.base/java/util/stream/Stream.html#toList()) to understand when and where this method could be used instead of a more traditional collector.


## Wrap-up

In this exercise, you have used **Records**, a new feature for the easy creation of immutable data aggregates. The Record feature went through 2 preview rounds (Java 14 & Java 15) and was made made final and permanent in Java 16.

For more details on Records, please check the following resources.

* [JEP 395: Records](https://openjdk.java.net/jeps/395)
* [Java Feature Spotlight: Records](https://inside.java/2020/02/04/spotlightrecords/)






